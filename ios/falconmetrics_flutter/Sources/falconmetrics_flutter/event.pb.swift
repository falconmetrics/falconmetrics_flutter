// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: event.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Base message for all tracking events
struct Pb_TrackingEvent: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var event: Pb_TrackingEvent.OneOf_Event? = nil

  var completeRegistration: Pb_CompleteRegistrationEvent {
    get {
      if case .completeRegistration(let v)? = event {return v}
      return Pb_CompleteRegistrationEvent()
    }
    set {event = .completeRegistration(newValue)}
  }

  var addedToCart: Pb_AddedToCartEvent {
    get {
      if case .addedToCart(let v)? = event {return v}
      return Pb_AddedToCartEvent()
    }
    set {event = .addedToCart(newValue)}
  }

  var subscribe: Pb_SubscriptionEvent {
    get {
      if case .subscribe(let v)? = event {return v}
      return Pb_SubscriptionEvent()
    }
    set {event = .subscribe(newValue)}
  }

  var purchase: Pb_PurchaseEvent {
    get {
      if case .purchase(let v)? = event {return v}
      return Pb_PurchaseEvent()
    }
    set {event = .purchase(newValue)}
  }

  var customEvent: Pb_CustomEvent {
    get {
      if case .customEvent(let v)? = event {return v}
      return Pb_CustomEvent()
    }
    set {event = .customEvent(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Event: Equatable, Sendable {
    case completeRegistration(Pb_CompleteRegistrationEvent)
    case addedToCart(Pb_AddedToCartEvent)
    case subscribe(Pb_SubscriptionEvent)
    case purchase(Pb_PurchaseEvent)
    case customEvent(Pb_CustomEvent)

  }

  init() {}
}

/// Event to track when a user completes their registration
struct Pb_CompleteRegistrationEvent: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Event to track a product being added to the cart
struct Pb_AddedToCartEvent: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The unique id of the item or product
  var itemID: String = String()

  /// The quantity of the item or product
  var quantity: Int32 = 0

  /// The price in cents or lowest currency unit
  var productPriceInCents: Int32 = 0

  /// The currency in ISO 4217 format (e.g., USD, JPY)
  var currency: String = String()

  /// The category of the product (optional)
  var productCategory: String {
    get {return _productCategory ?? String()}
    set {_productCategory = newValue}
  }
  /// Returns true if `productCategory` has been explicitly set.
  var hasProductCategory: Bool {return self._productCategory != nil}
  /// Clears the value of `productCategory`. Subsequent reads from it will return its default value.
  mutating func clearProductCategory() {self._productCategory = nil}

  /// The id (session id) of the cart (optional)
  var cartID: String {
    get {return _cartID ?? String()}
    set {_cartID = newValue}
  }
  /// Returns true if `cartID` has been explicitly set.
  var hasCartID: Bool {return self._cartID != nil}
  /// Clears the value of `cartID`. Subsequent reads from it will return its default value.
  mutating func clearCartID() {self._cartID = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _productCategory: String? = nil
  fileprivate var _cartID: String? = nil
}

/// Event to track a subscription
struct Pb_SubscriptionEvent: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The currency in ISO 4217 format (e.g., USD, JPY)
  var currency: String {
    get {return _currency ?? String()}
    set {_currency = newValue}
  }
  /// Returns true if `currency` has been explicitly set.
  var hasCurrency: Bool {return self._currency != nil}
  /// Clears the value of `currency`. Subsequent reads from it will return its default value.
  mutating func clearCurrency() {self._currency = nil}

  /// The predicted LTV value in cents (optional)
  var predictedLtvValueInCents: Int32 {
    get {return _predictedLtvValueInCents ?? 0}
    set {_predictedLtvValueInCents = newValue}
  }
  /// Returns true if `predictedLtvValueInCents` has been explicitly set.
  var hasPredictedLtvValueInCents: Bool {return self._predictedLtvValueInCents != nil}
  /// Clears the value of `predictedLtvValueInCents`. Subsequent reads from it will return its default value.
  mutating func clearPredictedLtvValueInCents() {self._predictedLtvValueInCents = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _currency: String? = nil
  fileprivate var _predictedLtvValueInCents: Int32? = nil
}

/// Event to track a purchase
struct Pb_PurchaseEvent: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The unique ids of the item or product
  var itemIds: [String] = []

  /// The quantity of the item or product
  var quantity: Int32 = 0

  /// The unique id of the transaction
  var transactionID: String = String()

  /// The price in cents or lowest currency unit
  var productPriceInCents: Int32 = 0

  /// The currency in ISO 4217 format (e.g., USD, JPY)
  var currency: String = String()

  /// The revenue in cents or lowest currency unit
  var revenueInCents: Int32 = 0

  /// The category of the product (optional)
  var productCategory: String {
    get {return _productCategory ?? String()}
    set {_productCategory = newValue}
  }
  /// Returns true if `productCategory` has been explicitly set.
  var hasProductCategory: Bool {return self._productCategory != nil}
  /// Clears the value of `productCategory`. Subsequent reads from it will return its default value.
  mutating func clearProductCategory() {self._productCategory = nil}

  /// The id (session id) of the cart (optional)
  var cartID: String {
    get {return _cartID ?? String()}
    set {_cartID = newValue}
  }
  /// Returns true if `cartID` has been explicitly set.
  var hasCartID: Bool {return self._cartID != nil}
  /// Clears the value of `cartID`. Subsequent reads from it will return its default value.
  mutating func clearCartID() {self._cartID = nil}

  /// The payment method (e.g., credit card, paypal) (optional)
  var paymentMethod: String {
    get {return _paymentMethod ?? String()}
    set {_paymentMethod = newValue}
  }
  /// Returns true if `paymentMethod` has been explicitly set.
  var hasPaymentMethod: Bool {return self._paymentMethod != nil}
  /// Clears the value of `paymentMethod`. Subsequent reads from it will return its default value.
  mutating func clearPaymentMethod() {self._paymentMethod = nil}

  /// The tax amount in cents (optional)
  var taxInCents: Int32 {
    get {return _taxInCents ?? 0}
    set {_taxInCents = newValue}
  }
  /// Returns true if `taxInCents` has been explicitly set.
  var hasTaxInCents: Bool {return self._taxInCents != nil}
  /// Clears the value of `taxInCents`. Subsequent reads from it will return its default value.
  mutating func clearTaxInCents() {self._taxInCents = nil}

  /// The shipping cost in cents (optional)
  var shippingCostInCents: Int32 {
    get {return _shippingCostInCents ?? 0}
    set {_shippingCostInCents = newValue}
  }
  /// Returns true if `shippingCostInCents` has been explicitly set.
  var hasShippingCostInCents: Bool {return self._shippingCostInCents != nil}
  /// Clears the value of `shippingCostInCents`. Subsequent reads from it will return its default value.
  mutating func clearShippingCostInCents() {self._shippingCostInCents = nil}

  /// The discount amount in cents (optional)
  var discountInCents: Int32 {
    get {return _discountInCents ?? 0}
    set {_discountInCents = newValue}
  }
  /// Returns true if `discountInCents` has been explicitly set.
  var hasDiscountInCents: Bool {return self._discountInCents != nil}
  /// Clears the value of `discountInCents`. Subsequent reads from it will return its default value.
  mutating func clearDiscountInCents() {self._discountInCents = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _productCategory: String? = nil
  fileprivate var _cartID: String? = nil
  fileprivate var _paymentMethod: String? = nil
  fileprivate var _taxInCents: Int32? = nil
  fileprivate var _shippingCostInCents: Int32? = nil
  fileprivate var _discountInCents: Int32? = nil
}

/// Event to track a custom event
struct Pb_CustomEvent: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The name of the event
  var eventName: String = String()

  /// Attributes associated with the event
  /// Values are restricted to primitive types (String, Int, Double, Boolean, etc.)
  var attributes: Dictionary<String,Pb_AttributeValue> = [:]

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Union type to represent primitive values for attributes
struct Pb_AttributeValue: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var value: Pb_AttributeValue.OneOf_Value? = nil

  var stringValue: String {
    get {
      if case .stringValue(let v)? = value {return v}
      return String()
    }
    set {value = .stringValue(newValue)}
  }

  var intValue: Int32 {
    get {
      if case .intValue(let v)? = value {return v}
      return 0
    }
    set {value = .intValue(newValue)}
  }

  var doubleValue: Double {
    get {
      if case .doubleValue(let v)? = value {return v}
      return 0
    }
    set {value = .doubleValue(newValue)}
  }

  var boolValue: Bool {
    get {
      if case .boolValue(let v)? = value {return v}
      return false
    }
    set {value = .boolValue(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Value: Equatable, Sendable {
    case stringValue(String)
    case intValue(Int32)
    case doubleValue(Double)
    case boolValue(Bool)

  }

  init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "pb"

extension Pb_TrackingEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TrackingEvent"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "complete_registration"),
    2: .standard(proto: "added_to_cart"),
    3: .same(proto: "subscribe"),
    4: .same(proto: "purchase"),
    5: .standard(proto: "custom_event"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Pb_CompleteRegistrationEvent?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .completeRegistration(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .completeRegistration(v)
        }
      }()
      case 2: try {
        var v: Pb_AddedToCartEvent?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .addedToCart(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .addedToCart(v)
        }
      }()
      case 3: try {
        var v: Pb_SubscriptionEvent?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .subscribe(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .subscribe(v)
        }
      }()
      case 4: try {
        var v: Pb_PurchaseEvent?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .purchase(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .purchase(v)
        }
      }()
      case 5: try {
        var v: Pb_CustomEvent?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .customEvent(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .customEvent(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.event {
    case .completeRegistration?: try {
      guard case .completeRegistration(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .addedToCart?: try {
      guard case .addedToCart(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .subscribe?: try {
      guard case .subscribe(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .purchase?: try {
      guard case .purchase(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .customEvent?: try {
      guard case .customEvent(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Pb_TrackingEvent, rhs: Pb_TrackingEvent) -> Bool {
    if lhs.event != rhs.event {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pb_CompleteRegistrationEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CompleteRegistrationEvent"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Pb_CompleteRegistrationEvent, rhs: Pb_CompleteRegistrationEvent) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pb_AddedToCartEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AddedToCartEvent"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "item_id"),
    2: .same(proto: "quantity"),
    3: .standard(proto: "product_price_in_cents"),
    4: .same(proto: "currency"),
    5: .standard(proto: "product_category"),
    6: .standard(proto: "cart_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.itemID) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.quantity) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.productPriceInCents) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.currency) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self._productCategory) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self._cartID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.itemID.isEmpty {
      try visitor.visitSingularStringField(value: self.itemID, fieldNumber: 1)
    }
    if self.quantity != 0 {
      try visitor.visitSingularInt32Field(value: self.quantity, fieldNumber: 2)
    }
    if self.productPriceInCents != 0 {
      try visitor.visitSingularInt32Field(value: self.productPriceInCents, fieldNumber: 3)
    }
    if !self.currency.isEmpty {
      try visitor.visitSingularStringField(value: self.currency, fieldNumber: 4)
    }
    try { if let v = self._productCategory {
      try visitor.visitSingularStringField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._cartID {
      try visitor.visitSingularStringField(value: v, fieldNumber: 6)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Pb_AddedToCartEvent, rhs: Pb_AddedToCartEvent) -> Bool {
    if lhs.itemID != rhs.itemID {return false}
    if lhs.quantity != rhs.quantity {return false}
    if lhs.productPriceInCents != rhs.productPriceInCents {return false}
    if lhs.currency != rhs.currency {return false}
    if lhs._productCategory != rhs._productCategory {return false}
    if lhs._cartID != rhs._cartID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pb_SubscriptionEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SubscriptionEvent"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "currency"),
    2: .standard(proto: "predicted_ltv_value_in_cents"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._currency) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self._predictedLtvValueInCents) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._currency {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._predictedLtvValueInCents {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Pb_SubscriptionEvent, rhs: Pb_SubscriptionEvent) -> Bool {
    if lhs._currency != rhs._currency {return false}
    if lhs._predictedLtvValueInCents != rhs._predictedLtvValueInCents {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pb_PurchaseEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PurchaseEvent"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "item_ids"),
    2: .same(proto: "quantity"),
    3: .standard(proto: "transaction_id"),
    4: .standard(proto: "product_price_in_cents"),
    5: .same(proto: "currency"),
    6: .standard(proto: "revenue_in_cents"),
    7: .standard(proto: "product_category"),
    8: .standard(proto: "cart_id"),
    9: .standard(proto: "payment_method"),
    10: .standard(proto: "tax_in_cents"),
    11: .standard(proto: "shipping_cost_in_cents"),
    12: .standard(proto: "discount_in_cents"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.itemIds) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.quantity) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.transactionID) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.productPriceInCents) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.currency) }()
      case 6: try { try decoder.decodeSingularInt32Field(value: &self.revenueInCents) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self._productCategory) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self._cartID) }()
      case 9: try { try decoder.decodeSingularStringField(value: &self._paymentMethod) }()
      case 10: try { try decoder.decodeSingularInt32Field(value: &self._taxInCents) }()
      case 11: try { try decoder.decodeSingularInt32Field(value: &self._shippingCostInCents) }()
      case 12: try { try decoder.decodeSingularInt32Field(value: &self._discountInCents) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.itemIds.isEmpty {
      try visitor.visitRepeatedStringField(value: self.itemIds, fieldNumber: 1)
    }
    if self.quantity != 0 {
      try visitor.visitSingularInt32Field(value: self.quantity, fieldNumber: 2)
    }
    if !self.transactionID.isEmpty {
      try visitor.visitSingularStringField(value: self.transactionID, fieldNumber: 3)
    }
    if self.productPriceInCents != 0 {
      try visitor.visitSingularInt32Field(value: self.productPriceInCents, fieldNumber: 4)
    }
    if !self.currency.isEmpty {
      try visitor.visitSingularStringField(value: self.currency, fieldNumber: 5)
    }
    if self.revenueInCents != 0 {
      try visitor.visitSingularInt32Field(value: self.revenueInCents, fieldNumber: 6)
    }
    try { if let v = self._productCategory {
      try visitor.visitSingularStringField(value: v, fieldNumber: 7)
    } }()
    try { if let v = self._cartID {
      try visitor.visitSingularStringField(value: v, fieldNumber: 8)
    } }()
    try { if let v = self._paymentMethod {
      try visitor.visitSingularStringField(value: v, fieldNumber: 9)
    } }()
    try { if let v = self._taxInCents {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 10)
    } }()
    try { if let v = self._shippingCostInCents {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 11)
    } }()
    try { if let v = self._discountInCents {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 12)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Pb_PurchaseEvent, rhs: Pb_PurchaseEvent) -> Bool {
    if lhs.itemIds != rhs.itemIds {return false}
    if lhs.quantity != rhs.quantity {return false}
    if lhs.transactionID != rhs.transactionID {return false}
    if lhs.productPriceInCents != rhs.productPriceInCents {return false}
    if lhs.currency != rhs.currency {return false}
    if lhs.revenueInCents != rhs.revenueInCents {return false}
    if lhs._productCategory != rhs._productCategory {return false}
    if lhs._cartID != rhs._cartID {return false}
    if lhs._paymentMethod != rhs._paymentMethod {return false}
    if lhs._taxInCents != rhs._taxInCents {return false}
    if lhs._shippingCostInCents != rhs._shippingCostInCents {return false}
    if lhs._discountInCents != rhs._discountInCents {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pb_CustomEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CustomEvent"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "event_name"),
    2: .same(proto: "attributes"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.eventName) }()
      case 2: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Pb_AttributeValue>.self, value: &self.attributes) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.eventName.isEmpty {
      try visitor.visitSingularStringField(value: self.eventName, fieldNumber: 1)
    }
    if !self.attributes.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Pb_AttributeValue>.self, value: self.attributes, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Pb_CustomEvent, rhs: Pb_CustomEvent) -> Bool {
    if lhs.eventName != rhs.eventName {return false}
    if lhs.attributes != rhs.attributes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pb_AttributeValue: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AttributeValue"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "string_value"),
    2: .standard(proto: "int_value"),
    3: .standard(proto: "double_value"),
    4: .standard(proto: "bool_value"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.value != nil {try decoder.handleConflictingOneOf()}
          self.value = .stringValue(v)
        }
      }()
      case 2: try {
        var v: Int32?
        try decoder.decodeSingularInt32Field(value: &v)
        if let v = v {
          if self.value != nil {try decoder.handleConflictingOneOf()}
          self.value = .intValue(v)
        }
      }()
      case 3: try {
        var v: Double?
        try decoder.decodeSingularDoubleField(value: &v)
        if let v = v {
          if self.value != nil {try decoder.handleConflictingOneOf()}
          self.value = .doubleValue(v)
        }
      }()
      case 4: try {
        var v: Bool?
        try decoder.decodeSingularBoolField(value: &v)
        if let v = v {
          if self.value != nil {try decoder.handleConflictingOneOf()}
          self.value = .boolValue(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.value {
    case .stringValue?: try {
      guard case .stringValue(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }()
    case .intValue?: try {
      guard case .intValue(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 2)
    }()
    case .doubleValue?: try {
      guard case .doubleValue(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularDoubleField(value: v, fieldNumber: 3)
    }()
    case .boolValue?: try {
      guard case .boolValue(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularBoolField(value: v, fieldNumber: 4)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Pb_AttributeValue, rhs: Pb_AttributeValue) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
