// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: event.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Base message for all tracking events
struct TrackingEvent: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var event: TrackingEvent.OneOf_Event? = nil

  var userSignedUpOrLoggedIn: UserSignedUpOrLoggedInEvent {
    get {
      if case .userSignedUpOrLoggedIn(let v)? = event {return v}
      return UserSignedUpOrLoggedInEvent()
    }
    set {event = .userSignedUpOrLoggedIn(newValue)}
  }

  var addedToCart: AddedToCartEvent {
    get {
      if case .addedToCart(let v)? = event {return v}
      return AddedToCartEvent()
    }
    set {event = .addedToCart(newValue)}
  }

  var couponApplied: CouponAppliedEvent {
    get {
      if case .couponApplied(let v)? = event {return v}
      return CouponAppliedEvent()
    }
    set {event = .couponApplied(newValue)}
  }

  var purchase: PurchaseEvent {
    get {
      if case .purchase(let v)? = event {return v}
      return PurchaseEvent()
    }
    set {event = .purchase(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Event: Equatable, Sendable {
    case userSignedUpOrLoggedIn(UserSignedUpOrLoggedInEvent)
    case addedToCart(AddedToCartEvent)
    case couponApplied(CouponAppliedEvent)
    case purchase(PurchaseEvent)

  }

  init() {}
}

/// Event to track a user signing up or logging in
struct UserSignedUpOrLoggedInEvent: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Event to track a product being added to the cart
struct AddedToCartEvent: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The unique id of the item or product
  var itemID: String = String()

  /// The quantity of the item or product
  var quantity: Int32 = 0

  /// The price in cents or lowest currency unit
  var productPriceInCents: Int32 = 0

  /// The currency in ISO 4217 format (e.g., USD, JPY)
  var currency: String = String()

  /// The category of the product (optional)
  var productCategory: String {
    get {return _productCategory ?? String()}
    set {_productCategory = newValue}
  }
  /// Returns true if `productCategory` has been explicitly set.
  var hasProductCategory: Bool {return self._productCategory != nil}
  /// Clears the value of `productCategory`. Subsequent reads from it will return its default value.
  mutating func clearProductCategory() {self._productCategory = nil}

  /// The id (session id) of the cart (optional)
  var cartID: String {
    get {return _cartID ?? String()}
    set {_cartID = newValue}
  }
  /// Returns true if `cartID` has been explicitly set.
  var hasCartID: Bool {return self._cartID != nil}
  /// Clears the value of `cartID`. Subsequent reads from it will return its default value.
  mutating func clearCartID() {self._cartID = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _productCategory: String? = nil
  fileprivate var _cartID: String? = nil
}

/// Event to track a coupon being applied to a cart
struct CouponAppliedEvent: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The unique code of the coupon
  var couponCode: String = String()

  /// The id (session id) of the cart (optional)
  var cartID: String {
    get {return _cartID ?? String()}
    set {_cartID = newValue}
  }
  /// Returns true if `cartID` has been explicitly set.
  var hasCartID: Bool {return self._cartID != nil}
  /// Clears the value of `cartID`. Subsequent reads from it will return its default value.
  mutating func clearCartID() {self._cartID = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _cartID: String? = nil
}

/// Event to track a purchase
struct PurchaseEvent: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The unique id of the item or product
  var itemID: String = String()

  /// The quantity of the item or product
  var quantity: Int32 = 0

  /// The unique id of the transaction
  var transactionID: String = String()

  /// The price in cents or lowest currency unit
  var productPriceInCents: Int32 = 0

  /// The currency in ISO 4217 format (e.g., USD, JPY)
  var currency: String = String()

  /// The revenue in cents or lowest currency unit
  var revenueInCents: Int32 = 0

  /// The category of the product (optional)
  var productCategory: String {
    get {return _productCategory ?? String()}
    set {_productCategory = newValue}
  }
  /// Returns true if `productCategory` has been explicitly set.
  var hasProductCategory: Bool {return self._productCategory != nil}
  /// Clears the value of `productCategory`. Subsequent reads from it will return its default value.
  mutating func clearProductCategory() {self._productCategory = nil}

  /// The id (session id) of the cart (optional)
  var cartID: String {
    get {return _cartID ?? String()}
    set {_cartID = newValue}
  }
  /// Returns true if `cartID` has been explicitly set.
  var hasCartID: Bool {return self._cartID != nil}
  /// Clears the value of `cartID`. Subsequent reads from it will return its default value.
  mutating func clearCartID() {self._cartID = nil}

  /// The payment method (e.g., credit card, paypal) (optional)
  var paymentMethod: String {
    get {return _paymentMethod ?? String()}
    set {_paymentMethod = newValue}
  }
  /// Returns true if `paymentMethod` has been explicitly set.
  var hasPaymentMethod: Bool {return self._paymentMethod != nil}
  /// Clears the value of `paymentMethod`. Subsequent reads from it will return its default value.
  mutating func clearPaymentMethod() {self._paymentMethod = nil}

  /// The tax amount in cents (optional)
  var taxInCents: Int32 {
    get {return _taxInCents ?? 0}
    set {_taxInCents = newValue}
  }
  /// Returns true if `taxInCents` has been explicitly set.
  var hasTaxInCents: Bool {return self._taxInCents != nil}
  /// Clears the value of `taxInCents`. Subsequent reads from it will return its default value.
  mutating func clearTaxInCents() {self._taxInCents = nil}

  /// The shipping cost in cents (optional)
  var shippingCostInCents: Int32 {
    get {return _shippingCostInCents ?? 0}
    set {_shippingCostInCents = newValue}
  }
  /// Returns true if `shippingCostInCents` has been explicitly set.
  var hasShippingCostInCents: Bool {return self._shippingCostInCents != nil}
  /// Clears the value of `shippingCostInCents`. Subsequent reads from it will return its default value.
  mutating func clearShippingCostInCents() {self._shippingCostInCents = nil}

  /// The discount amount in cents (optional)
  var discountInCents: Int32 {
    get {return _discountInCents ?? 0}
    set {_discountInCents = newValue}
  }
  /// Returns true if `discountInCents` has been explicitly set.
  var hasDiscountInCents: Bool {return self._discountInCents != nil}
  /// Clears the value of `discountInCents`. Subsequent reads from it will return its default value.
  mutating func clearDiscountInCents() {self._discountInCents = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _productCategory: String? = nil
  fileprivate var _cartID: String? = nil
  fileprivate var _paymentMethod: String? = nil
  fileprivate var _taxInCents: Int32? = nil
  fileprivate var _shippingCostInCents: Int32? = nil
  fileprivate var _discountInCents: Int32? = nil
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

extension TrackingEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "TrackingEvent"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_signed_up_or_logged_in"),
    2: .standard(proto: "added_to_cart"),
    3: .standard(proto: "coupon_applied"),
    4: .same(proto: "purchase"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: UserSignedUpOrLoggedInEvent?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .userSignedUpOrLoggedIn(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .userSignedUpOrLoggedIn(v)
        }
      }()
      case 2: try {
        var v: AddedToCartEvent?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .addedToCart(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .addedToCart(v)
        }
      }()
      case 3: try {
        var v: CouponAppliedEvent?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .couponApplied(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .couponApplied(v)
        }
      }()
      case 4: try {
        var v: PurchaseEvent?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .purchase(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .purchase(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.event {
    case .userSignedUpOrLoggedIn?: try {
      guard case .userSignedUpOrLoggedIn(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .addedToCart?: try {
      guard case .addedToCart(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .couponApplied?: try {
      guard case .couponApplied(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .purchase?: try {
      guard case .purchase(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TrackingEvent, rhs: TrackingEvent) -> Bool {
    if lhs.event != rhs.event {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension UserSignedUpOrLoggedInEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "UserSignedUpOrLoggedInEvent"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: UserSignedUpOrLoggedInEvent, rhs: UserSignedUpOrLoggedInEvent) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension AddedToCartEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "AddedToCartEvent"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "item_id"),
    2: .same(proto: "quantity"),
    3: .standard(proto: "product_price_in_cents"),
    4: .same(proto: "currency"),
    5: .standard(proto: "product_category"),
    6: .standard(proto: "cart_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.itemID) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.quantity) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.productPriceInCents) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.currency) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self._productCategory) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self._cartID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.itemID.isEmpty {
      try visitor.visitSingularStringField(value: self.itemID, fieldNumber: 1)
    }
    if self.quantity != 0 {
      try visitor.visitSingularInt32Field(value: self.quantity, fieldNumber: 2)
    }
    if self.productPriceInCents != 0 {
      try visitor.visitSingularInt32Field(value: self.productPriceInCents, fieldNumber: 3)
    }
    if !self.currency.isEmpty {
      try visitor.visitSingularStringField(value: self.currency, fieldNumber: 4)
    }
    try { if let v = self._productCategory {
      try visitor.visitSingularStringField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._cartID {
      try visitor.visitSingularStringField(value: v, fieldNumber: 6)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: AddedToCartEvent, rhs: AddedToCartEvent) -> Bool {
    if lhs.itemID != rhs.itemID {return false}
    if lhs.quantity != rhs.quantity {return false}
    if lhs.productPriceInCents != rhs.productPriceInCents {return false}
    if lhs.currency != rhs.currency {return false}
    if lhs._productCategory != rhs._productCategory {return false}
    if lhs._cartID != rhs._cartID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CouponAppliedEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "CouponAppliedEvent"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "coupon_code"),
    2: .standard(proto: "cart_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.couponCode) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._cartID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.couponCode.isEmpty {
      try visitor.visitSingularStringField(value: self.couponCode, fieldNumber: 1)
    }
    try { if let v = self._cartID {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CouponAppliedEvent, rhs: CouponAppliedEvent) -> Bool {
    if lhs.couponCode != rhs.couponCode {return false}
    if lhs._cartID != rhs._cartID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PurchaseEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "PurchaseEvent"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "item_id"),
    2: .same(proto: "quantity"),
    3: .standard(proto: "transaction_id"),
    4: .standard(proto: "product_price_in_cents"),
    5: .same(proto: "currency"),
    6: .standard(proto: "revenue_in_cents"),
    7: .standard(proto: "product_category"),
    8: .standard(proto: "cart_id"),
    9: .standard(proto: "payment_method"),
    10: .standard(proto: "tax_in_cents"),
    11: .standard(proto: "shipping_cost_in_cents"),
    12: .standard(proto: "discount_in_cents"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.itemID) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.quantity) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.transactionID) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.productPriceInCents) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.currency) }()
      case 6: try { try decoder.decodeSingularInt32Field(value: &self.revenueInCents) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self._productCategory) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self._cartID) }()
      case 9: try { try decoder.decodeSingularStringField(value: &self._paymentMethod) }()
      case 10: try { try decoder.decodeSingularInt32Field(value: &self._taxInCents) }()
      case 11: try { try decoder.decodeSingularInt32Field(value: &self._shippingCostInCents) }()
      case 12: try { try decoder.decodeSingularInt32Field(value: &self._discountInCents) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.itemID.isEmpty {
      try visitor.visitSingularStringField(value: self.itemID, fieldNumber: 1)
    }
    if self.quantity != 0 {
      try visitor.visitSingularInt32Field(value: self.quantity, fieldNumber: 2)
    }
    if !self.transactionID.isEmpty {
      try visitor.visitSingularStringField(value: self.transactionID, fieldNumber: 3)
    }
    if self.productPriceInCents != 0 {
      try visitor.visitSingularInt32Field(value: self.productPriceInCents, fieldNumber: 4)
    }
    if !self.currency.isEmpty {
      try visitor.visitSingularStringField(value: self.currency, fieldNumber: 5)
    }
    if self.revenueInCents != 0 {
      try visitor.visitSingularInt32Field(value: self.revenueInCents, fieldNumber: 6)
    }
    try { if let v = self._productCategory {
      try visitor.visitSingularStringField(value: v, fieldNumber: 7)
    } }()
    try { if let v = self._cartID {
      try visitor.visitSingularStringField(value: v, fieldNumber: 8)
    } }()
    try { if let v = self._paymentMethod {
      try visitor.visitSingularStringField(value: v, fieldNumber: 9)
    } }()
    try { if let v = self._taxInCents {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 10)
    } }()
    try { if let v = self._shippingCostInCents {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 11)
    } }()
    try { if let v = self._discountInCents {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 12)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PurchaseEvent, rhs: PurchaseEvent) -> Bool {
    if lhs.itemID != rhs.itemID {return false}
    if lhs.quantity != rhs.quantity {return false}
    if lhs.transactionID != rhs.transactionID {return false}
    if lhs.productPriceInCents != rhs.productPriceInCents {return false}
    if lhs.currency != rhs.currency {return false}
    if lhs.revenueInCents != rhs.revenueInCents {return false}
    if lhs._productCategory != rhs._productCategory {return false}
    if lhs._cartID != rhs._cartID {return false}
    if lhs._paymentMethod != rhs._paymentMethod {return false}
    if lhs._taxInCents != rhs._taxInCents {return false}
    if lhs._shippingCostInCents != rhs._shippingCostInCents {return false}
    if lhs._discountInCents != rhs._discountInCents {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
